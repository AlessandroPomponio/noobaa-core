/* jshint node:true */
'use strict';


// class representation of binary galois field GF(2^w)
// where p is a primitive polynom of degree w.
function GF(p) {
    this.p = p;
    this.w = poly_degree(p);

    // TODO the code still can't handle 31 and 32 bits
    // because of overflows on the sign bit (might affect <> comparisons)
    // or overflow above the js 32 bit limit for bitwise ops.
    if (this.w > 30) {
        throw new Error('degree too big ' + this.w);
    }

    this.size = 1 << this.w;
    this.max = this.size - 1;
}


// http://web.eecs.utk.edu/~plank/plank/papers/CS-07-593/primitive-polynomial-table.txt
// TODO keep the full list of primitive polynoms
GF.PRIMITIVE_POLYNOMS = {
    2: 0x7,
    4: 0x13,
    8: 0x11d,
    16: 0x1100b,
    // 16: 0x138cb,
    20: 0x100009,
    24: 0x1000087,
    28: 0x10000009,
    30: 0x40800007,
};


// generate log and exp tables for the primitive polynom.
GF.prototype.init_log_table = function() {
    var i = 0;
    var a = 1;
    var log_table, exp_table;

    if (this.w > 24) {
        return false;
    }

    log_table = new Uint32Array(this.size);
    exp_table = new Uint32Array(this.size);
    log_table[0] = undefined;
    exp_table[0] = 0;

    // the process starts from the polynom a=1 and on each step it
    // multiplies a by the polynom x, which effectively means: a<<1 mod p.
    // when p is a primitive polynom this loop will iterate through all the
    // elements of GF(2^w) in the order of exponents - 1, x, x^2, x^3, ...
    do {
        log_table[a] = i;
        exp_table[i] = a;
        i += 1;
        a <<= 1;
        if (a & this.size) {
            a ^= this.p;
        }
    } while (a !== 1);

    this.log_table = log_table;
    this.exp_table = exp_table;
    // override the mult function to use the log table
    this.mult = this.mult_with_log;
    return true;
};


// calculate a * b in GF(2^w) generated by the primitive polynom p.
// expects: deg(a), deg(b) < w.
GF.prototype.mult_with_modulo = function(a, b) {
    var result = 0;

    // the calculation is done by multiplying a and b as polynoms modulo p.
    // the modulo is used also during the polynom multiplication to avoid overflow.
    while (a && b) {
        // in every stage of the loop we "add" (which is xor in GF) b to
        // the result if a has the lowest bit on, which means that in polynom
        // representation a(x) = ... + 1
        if (a & 1) {
            result ^= b;
        }
        // we can now remove the 1's from a, and increase the degree of b
        // to advance to the next element in the multiplication.
        a >>>= 1;
        b <<= 1;
        // fix b to be modulo p, and avoid overflow from 32 bit
        if (b & this.size) {
            b ^= this.p;
        }
    }
    return result;
};


// use mult_with_modulo by default, unless overriden by init_log_table.
GF.prototype.mult = GF.prototype.mult_with_modulo;


// calculate a * b in GF(2^w) using the log and exp tables.
// using the formula: a * b = exp( log(a) + log(b) )
GF.prototype.mult_with_log = function(a, b) {
    if (!a || !b) {
        return 0;
    }
    var l = this.log_table[a] + this.log_table[b];
    if (l >= this.max) {
        l -= this.max;
    }
    return this.exp_table[l];
};


// calculate a / b in GF(2^w) using the log and exp tables.
// using the formula: a / b = exp( log(a) - log(b) )
GF.prototype.div_with_log = function(a, b) {
    if (!a) {
        return 0;
    }
    if (!b) {
        return undefined;
    }
    var l = this.log_table[a] - this.log_table[b];
    if (l < 0) {
        l += this.max;
    }
    return this.exp_table[l];
};

// find the inverse of a using: exp( log(a) + log(a^-1) ) = 1
// so log(a^-1) = 2^w - log(a)
GF.prototype.inverse = function(a) {
    if (!a) {
        return undefined;
    }
    var l = this.max - this.log_table[a] + 1;
    return this.exp_table[l];
};

GF.prototype.log = function(a) {
    return this.log_table[a];
};

GF.prototype.exp = function(l) {
    return this.exp_table[l];
};




// calculate a modulo b using long polynom division.
//
// NOTE: this is a *slow* implementation because it makes no assumptions.
// for faster code see how mult_with_modulo handles modulo with single xor
// by assuming only the w bit might become set during it's operation.
//
// here is a long division example:
//  w = 2
//  b = 0x7   =       111 = x^2 + x + 1
//  a = 0x1fc = 111111100 = x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2
//  d = deg(a)-w = 6
//	===========
// 	  111111100 	--> result = a
//  ^ 111			--> b << d, d=6
// 	===========
//	     111100 	--> result
//  ^    111		--> b << d, d=3
// 	===========
//	        100		--> result
//  ^       111		--> b << d, d=0
// 	===========
//	         11		--> result - a mod b
function poly_modulo(a, b) {
    var result = a;
    var w = poly_degree(b);
    var d = poly_degree(a) - w;

    // in each loop we subtract (xor) with b shifted exactly to cancel
    // the next highest bit of result, until the result degree is less than w.
    while (d >= 0) {
        result ^= (b << d);
        d = poly_degree(result) - w;
    }
    return result;
}


// return the polynom degree of a.
//
// note that deg(0) = deg(1) = 0 because both 0 and 1 represent a
// constant polynom of degree 0.
//
// more examples:
// deg(7)=2 because 7 has the polynom form of: x^2 + x + 1
// deg(0x1001)=12 because 0x1001 has the polynom form of: x^12 + 1
function poly_degree(a) {
    var n = 0;

    if (a & 0xFFFF0000) {
        n += 16;
        a >>>= 16;
    }
    if (a & 0xFFFFFF00) {
        n += 8;
        a >>>= 8;
    }
    if (a & 0xFFFFFFF0) {
        n += 4;
        a >>>= 4;
    }
    if (a & 0xFFFFFFFC) {
        n += 2;
        a >>>= 2;
    }
    if (a & 0xFFFFFFFE) {
        n += 1;
    }
    return n;
}


// TESTS


function gf_test_all() {
    var run_async;
    if (typeof(setImmediate) === 'function') {
        run_async = setImmediate;
    } else {
        run_async = function(fn) {
            setTimeout(fn, 0);
        };
    }

    var widths = Object.keys(GF.PRIMITIVE_POLYNOMS);
    var i = 0;

    next_test();

    function next_test() {
        if (i >= widths.length) {
            console.log(' ');
            console.log('FIN.');
            console.log(' ');
            return;
        }
        var w = widths[i];
        var p = GF.PRIMITIVE_POLYNOMS[w];
        i += 1;

        console.log(' ');
        console.log('******', w, '******');

        var gf = new GF(p);

        console.log(' ');
        console.log(' -- MODULO --');
        test_gf(gf, function() {

            if (!gf.init_log_table()) {
                return next_test();
            }
            console.log(' ');
            console.log(' -- LOG --');
            test_gf(gf, next_test);
        });
    }

    function test_gf(gf, callback) {
        var state = {
            a: 0,
            b: 0,
            a_inverse: 0,
            count: 0,
            start_time: Date.now(),
            report_seconds: 0,
        };

        test_gf_next_step();

        function test_gf_next_step() {
            var done;
            try {
                done = test_gf_step(gf, state, 10000000);

                // report progress
                var seconds = (Date.now() - state.start_time) / 1000;
                if (done || seconds >= state.report_seconds + 1) {
                    state.report_seconds = seconds;
                    var speed = state.count / seconds;
                    var completed = state.a * 100 / gf.size;
                    console.log(' ... completed', completed.toFixed(2), '%',
                        'speed', speed.toFixed(0), 'mult/sec');
                    // don't run too long for big fields
                    if (gf.w > 16 && seconds >= 2) {
                        done = true;
                    } else if (gf.w === 16 && seconds >= 2) {
                        done = true;
                    }
                }
            } catch (err) {
                console.error(err, err.stack);
                return; // don't run more callbacks
            }

            if (!done) {
                run_async(test_gf_next_step);
            } else {
                callback();
            }
        }
    }

    function test_gf_step(gf, state, cycles) {
        var done = false;
        // make vars local for performance
        var a = state.a;
        var b = state.b;
        var a_inverse = state.a_inverse;
        var count = 0;

        for (var i = 0; i < cycles; i++, b++) {

            if (b > gf.max) {
                if (a && !a_inverse) {
                    throw new Error('inverse not found for ' + a.toString(2));
                }
                a += 1;
                b = 0;
                a_inverse = 0;
                if (a > gf.max) {
                    done = true;
                    break;
                }
            }

            // check validity of result
            var result = gf.mult(a, b);
            count += 1;
            if (typeof(result) !== 'number' || result >= gf.size || result < 0) {
                throw new Error('bad result not in range ' +
                    a.toString(2) + ' * ' + b.toString(2) +
                    ' = ' + (result && result.toString(2)));
            }

            // checking inverse
            if (result === 1) {
                if (!a_inverse) {
                    a_inverse = b;
                } else if (a_inverse !== b) {
                    throw new Error('inverse already found for ' +
                        a.toString(2) + ' ' + a_inverse.toString(2));
                }
            }

            // checking field commutativity - a*b = b*a
            var result2 = gf.mult(b, a);
            count += 1;
            if (result !== result2) {
                throw new Error('not commutative ' +
                    a.toString(2) + ' * ' + b.toString(2) +
                    ' = ' + result.toString(2) + ' or ' + result2.toString(2));
            }
        }

        state.a = a;
        state.b = b;
        state.a_inverse = a_inverse;
        state.count += count;

        return done;
    }
}

if (typeof(require) === 'function' && require.main === module) {
    gf_test_all();
}

if (typeof(exports) === 'object') {
    exports = module.exports = {
        GF: GF,
        poly_degree: poly_degree,
        poly_modulo: poly_modulo,
    };
}
