/* jshint node:true */
'use strict';


// return the polynom degree of a.
// notice that deg(0) = deg(1) = 0 because both 0 and 1 represent
// a constant polynom of degree 0.
// a different example is deg(7)=2 because 7 has the polynom form of: x^2 + x + 1
// last example is deg(0x1001)=12 because 0x1001 has the polynom form of: x^12 + 1
function gf_degree(a) {
    var n = 0;

    if (a & 0xFFFF0000) {
        n += 16;
        a >>>= 16;
    }
    if (a & 0xFFFFFF00) {
        n += 8;
        a >>>= 8;
    }
    if (a & 0xFFFFFFF0) {
        n += 4;
        a >>>= 4;
    }
    if (a & 0xFFFFFFFC) {
        n += 2;
        a >>>= 2;
    }
    if (a & 0xFFFFFFFE) {
        n += 1;
    }
    return n;
}


// calculate a modulo p using long polynom division.
// here is a long division example:
//  w = 2
//  p = 0x7   =       111 = x^2 + x + 1
//  a = 0x1fc = 111111100 = x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2
//  d = deg(a)-w = 6
//	===========
// 	  111111100 	--> result = a
//  ^ 111			--> p << d, d=6
// 	===========
//	     111100 	--> result
//  ^    111		--> p << d, d=3
// 	===========
//	        100		--> result
//  ^       111		--> p << d, d=0
// 	===========
//	         11		--> result - a mod p
function gf_modulo(w, p, a) {
    var result = a;
    var d = gf_degree(a) - w;

    // in each loop we subtract (xor) with p shifted exactly to cancel
    // the next highest bit of result, until the result degree is less than w.
    while (d >= 0) {
        result ^= (p << d);
        d = gf_degree(result) - w;
    }
    return result;
}


// calculate a * b in GF(2^w) generated by the primitive polynom p.
// the calculation is done by multiplying a and b as polynoms modulo p.
// the modulo is used also during the polynom multiplication to avoid overflow.
function gf_mult_with_poly(w, p, a, b) {
    var result = 0;

    while (a && b) {
        // in every stage of the loop we add (xor) b to the result
        // if a has the lowest bit on, which means that in polynom
        // representation a(x) = ... + 1
        if (a & 1) {
            result ^= b;
        }
        // here we modulo b to avoid overflow from 32 bit
        // but we try to save some cycles and call only when must.
        if (b & 0x80000000) {
            b = gf_modulo(w, p, b);
        }
        // for next loop decrease the degree of a and increase a degree of b
        a >>>= 1;
        b <<= 1;
    }
    return gf_modulo(w, p, result);
}


// generate log and exp tables for the primitive polynom p.
// the process starts from the polynom a=1 and on each step it
// multiplies a by the polynom x, which effectively means: a<<1 mod p.
// when p is a primitive polynom this loop will iterate through all the
// elements of GF(2^w) in the order of exponents - 1, x, x^2, x^3, ...
function gf_init_generator(w, p) {
    if (w > 30) {
        throw new Error('w too big ' + w);
    }
    var i = 0;
    var a = 1;
    var generator = {
        w: w,
        p: p,
        log: [],
        exp: [],
        max: ~(~0 >>> w << w),
    };

    generator.log[0] = undefined;
    generator.exp[0] = 1;
    do {
        generator.log[a] = i;
        generator.exp[i] = a;
        a = gf_modulo(w, p, a << 1);
        i++;
    } while (a !== 1);

    return generator;
}


// calculate a * b in GF(2^w) using the generator log and exp tables.
// the basic approach uses this property:
//   a * b = exp( log(a) + log(b) )
function gf_mult_with_generator(generator, a, b) {
    if (!a || !b) {
        return 0;
    }
    var l = generator.log[a] + generator.log[b];
    if (l >= generator.max) {
        l -= generator.max;
    }
    return generator.exp[l];
}


// http://web.eecs.utk.edu/~plank/plank/papers/CS-07-593/primitive-polynomial-table.txt
var gf_primitive_poly = {
    2: 0x7,
    4: 0x13,
    8: 0x11d,
    16: 0x1100b,
    20: 0x100009,
    24: 0x1000087,
    28: 0x10000009,
    30: 0x40800007,
};


// test the given mult function for correctness of the field.
function test_mult_func(w, mult_func) {
    if (w > 30) {
        throw new Error('w too big ' + w);
    }
    var max = 1 << w;
    var x, y, z;
    var result, result2;
    var inverses = [];
    var x_inverse;
    var count = 0;
    var start_time = Date.now();

    for (x = 0; x < max; x++) {
        if (count > 20000000) {
            break;
        }
        // inverse can be set by previous loop
        x_inverse = inverses[x];

        for (y = 0; y < max; y++) {
            result = mult_func(x, y);
            count++;

            // check validity of
            if (typeof(result) !== 'number' || result >= max || result < 0) {
                throw new Error('bad result not in range ' +
                    x.toString(2) + ' * ' + y.toString(2) +
                    ' = ' + (result && result.toString(2)));
            }

            // checking inverse
            if (result === 1) {
                if (!x_inverse) {
                    x_inverse = inverses[x] = y;
                } else if (x_inverse !== y) {
                    throw new Error('inverse already found for ' +
                        x.toString(2) + ' ' + x_inverse.toString(2));
                }
            }

            // checking field commutativity - a*b = b*a
            result2 = mult_func(y, x);
            count++;
            if (result !== result2) {
                throw new Error('not commutative ' +
                    x.toString(2) + ' * ' + y.toString(2) +
                    ' = ' + result.toString(2) + ' or ' + result2.toString(2));
            }

            /*
			// checking field distributivity for (+,*)
            for (z = 0; z < max; z++) {
            	assert.strictEqual(m(x, y ^ z), m(x, y) ^ m(x, z));
            	assert.strictEqual(m(x, m(y, z)), m(m(x, y), z));
            }
			*/
            if (count % 5000000 === 0) {
                console.log(count + ' >>>');
            } else if (count % 500000 === 0) {
                if (typeof(process) === 'object') {
                    process.stdout.write('.');
                }
            }
        }
        if (x) {
            if (!x_inverse) {
                throw new Error('inverse not found for ' + x.toString(2));
            }
            if (!inverses[x_inverse]) {
                inverses[x_inverse] = x;
            } else if (inverses[x_inverse] !== x) {
                throw new Error('inverse disagree for ' +
                    x.toString(2) + ' ' + x_inverse.toString(2));
            }
        }
    }

    var end_time = Date.now();
    console.log('performance:', (count / ((end_time - start_time) / 1000)).toFixed(0),
        'mult/sec');
}

function gf_test_mult_with_poly(w) {
    console.log(' ');
    console.log('w', '=', w);
    console.log('test mult with poly');
    test_mult_func(w, gf_mult_with_poly.bind(null, w, gf_primitive_poly[w]));
    console.log('done');
}

function gf_test_mult_with_generator(w) {
    console.log(' ');
    console.log('w', '=', w);
    console.log('test mult with generator');
    var generator = gf_init_generator(w, gf_primitive_poly[w]);
    console.log('inited');
    test_mult_func(w, gf_mult_with_generator.bind(null, generator));
    console.log('done');
}


function gf_test_all() {
    var widths = Object.keys(gf_primitive_poly);
    for (var i = 0; i < widths.length; i++) {
        var w = widths[i];
        if (w <= 16) {
            gf_test_mult_with_poly(w);
            gf_test_mult_with_generator(w);
        }
    }
}

if (typeof(require) === 'function' && require.main === module) {
    gf_test_all();
}

var galois = {
    gf_degree: gf_degree,
    gf_modulo: gf_modulo,
    gf_mult_with_poly: gf_mult_with_poly,
    gf_mult_with_generator: gf_mult_with_generator,
    gf_init_generator: gf_init_generator,
};

if (typeof(exports) === 'object') {
    exports = module.exports = galois;
}
