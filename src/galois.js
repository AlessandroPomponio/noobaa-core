/* jshint node:true */
'use strict';


// class representation of binary galois field GF(2^w)
// where p is a primitive polynom of degree w.
function GF(p) {
    this.p = p;
    this.w = poly_degree(p);

    // TODO the code still can't handle 31 and 32 bits
    // because of overflows on the sign bit (might affect <> comparisons)
    // or overflow above the js 32 bit limit for bitwise ops.
    if (this.w > 30) {
        throw new Error('degree too big ' + this.w);
    }

    this.size = 1 << this.w;
    this.max = this.size - 1;
}


// http://web.eecs.utk.edu/~plank/plank/papers/CS-07-593/primitive-polynomial-table.txt
// TODO keep the full list of primitive polynoms
GF.PRIMITIVE_POLYNOMS = {
    2: 0x7,
    4: 0x13,
    8: 0x11d,
    // 16: 0x1100b,
    16: 0x138cb,
    20: 0x100009,
    24: 0x1000087,
    28: 0x10000009,
    30: 0x40800007,
};


// generate log and exp tables for the primitive polynom.
GF.prototype.init_log_table = function() {
    var i = 0;
    var a = 1;
    var log_table = new Uint32Array(this.size);
    var exp_table = new Uint32Array(this.size);
    log_table[0] = undefined;
    exp_table[0] = 0;

    if (this.w > 24) {
        return false;
    }

    // the process starts from the polynom a=1 and on each step it
    // multiplies a by the polynom x, which effectively means: a<<1 mod p.
    // when p is a primitive polynom this loop will iterate through all the
    // elements of GF(2^w) in the order of exponents - 1, x, x^2, x^3, ...
    do {
        log_table[a] = i;
        exp_table[i] = a;
        i += 1;
        a <<= 1;
        if (a & this.size) {
            a ^= this.p;
        }
    } while (a !== 1);

    this.log_table = log_table;
    this.exp_table = exp_table;
    // override the mult function to use the log table
    this.mult = this.mult_with_log;
    return true;
};


// calculate a * b in GF(2^w) generated by the primitive polynom p.
// expects: deg(a), deg(b) < w.
GF.prototype.mult_with_modulo = function(a, b) {
    var result = 0;

    // the calculation is done by multiplying a and b as polynoms modulo p.
    // the modulo is used also during the polynom multiplication to avoid overflow.
    while (a && b) {
        // in every stage of the loop we "add" (which is xor in GF) b to
        // the result if a has the lowest bit on, which means that in polynom
        // representation a(x) = ... + 1
        if (a & 1) {
            result ^= b;
        }
        // we can now remove the 1's from a, and increase the degree of b
        // to advance to the next element in the multiplication.
        a >>>= 1;
        b <<= 1;
        // fix b to be modulo p, and avoid overflow from 32 bit
        if (b & this.size) {
            b ^= this.p;
        }
    }
    return result;
};


// use mult_with_modulo by default, unless overriden by init_log_table.
GF.prototype.mult = GF.prototype.mult_with_modulo;


// calculate a * b in GF(2^w) using the log and exp tables.
// using the formula: a * b = exp( log(a) + log(b) )
GF.prototype.mult_with_log = function(a, b) {
    if (!a || !b) {
        return 0;
    }
    var l = this.log_table[a] + this.log_table[b];
    if (l >= this.max) {
        l -= this.max;
    }
    return this.exp_table[l];
};


// calculate a / b in GF(2^w) using the log and exp tables.
// using the formula: a / b = exp( log(a) - log(b) )
GF.prototype.div_with_log = function(a, b) {
    if (!a) {
        return 0;
    }
    if (!b) {
        return undefined;
    }
    var l = this.log_table[a] - this.log_table[b];
    if (l < 0) {
        l += this.max;
    }
    return this.exp_table[l];
};

// find the inverse of a using: exp( log(a) + log(a^-1) ) = 1
// so log(a^-1) = 2^w - log(a)
GF.prototype.inverse = function(a) {
    if (!a) {
        return undefined;
    }
    var l = this.max - this.log_table[a] + 1;
    return this.exp_table[l];
};

GF.prototype.log = function(a) {
    return this.log_table[a];
};

GF.prototype.exp = function(l) {
    return this.exp_table[l];
};




// calculate a modulo b using long polynom division.
//
// NOTE: this is a *slow* implementation because it makes no assumptions.
// for faster code see how mult_with_modulo handles modulo with single xor
// by assuming only the w bit might become set during it's operation.
//
// here is a long division example:
//  w = 2
//  b = 0x7   =       111 = x^2 + x + 1
//  a = 0x1fc = 111111100 = x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2
//  d = deg(a)-w = 6
//	===========
// 	  111111100 	--> result = a
//  ^ 111			--> b << d, d=6
// 	===========
//	     111100 	--> result
//  ^    111		--> b << d, d=3
// 	===========
//	        100		--> result
//  ^       111		--> b << d, d=0
// 	===========
//	         11		--> result - a mod b
function poly_modulo(a, b) {
    var result = a;
    var w = poly_degree(b);
    var d = poly_degree(a) - w;

    // in each loop we subtract (xor) with b shifted exactly to cancel
    // the next highest bit of result, until the result degree is less than w.
    while (d >= 0) {
        result ^= (b << d);
        d = poly_degree(result) - w;
    }
    return result;
}


// return the polynom degree of a.
//
// note that deg(0) = deg(1) = 0 because both 0 and 1 represent a
// constant polynom of degree 0.
//
// more examples:
// deg(7)=2 because 7 has the polynom form of: x^2 + x + 1
// deg(0x1001)=12 because 0x1001 has the polynom form of: x^12 + 1
function poly_degree(a) {
    var n = 0;

    if (a & 0xFFFF0000) {
        n += 16;
        a >>>= 16;
    }
    if (a & 0xFFFFFF00) {
        n += 8;
        a >>>= 8;
    }
    if (a & 0xFFFFFFF0) {
        n += 4;
        a >>>= 4;
    }
    if (a & 0xFFFFFFFC) {
        n += 2;
        a >>>= 2;
    }
    if (a & 0xFFFFFFFE) {
        n += 1;
    }
    return n;
}


// TESTS


function gf_test_all() {
    var widths = Object.keys(GF.PRIMITIVE_POLYNOMS);
    for (var i = 0; i < widths.length; i++) {
        var w = widths[i];
        var p = GF.PRIMITIVE_POLYNOMS[w];
        gf_test_one(w, p);
    }
}

function gf_test_one(w, p) {
    console.log(' ');
    console.log('******', w, '******');

    var gf = new GF(p);

    console.log(' ');
    console.log(' -- MODULO --');
    gf_test_mult_func(gf);

    if (gf.init_log_table()) {
        console.log(' ');
        console.log(' -- LOG --');
        gf_test_mult_func(gf);
    }
}

// test the given mult function for correctness of the field.
function gf_test_mult_func(gf) {
    var a, b;
    var result, result2;
    var inverses = [];
    var a_inverse;
    var count = 0;
    var start_time = Date.now();
    var report_seconds = 0;
    var stopped = false;

    var report = function(fin) {
        var seconds = (Date.now() - start_time) / 1000;
        if (!fin && seconds < report_seconds + 2) {
            return;
        }
        report_seconds = seconds;
        var speed = count / seconds;
        var completed = a * 100 / gf.size;
        console.log(' ... completed', completed.toFixed(2), '%',
            'speed', speed.toFixed(0), 'mult/sec');
        // don't run too long for big fields
        if (gf.w >= 16 && seconds >= 10) {
            stopped = true;
            return true;
        }
    };

    for (a = 0; a < gf.size; a++) {
        // inverse can be set by previous loop
        a_inverse = inverses[a];

        for (b = 0; b < gf.size; b++) {
            result = gf.mult(a, b);
            count++;

            // check validity of
            if (typeof(result) !== 'number' || result >= gf.size || result < 0) {
                throw new Error('bad result not in range ' +
                    a.toString(2) + ' * ' + b.toString(2) +
                    ' = ' + (result && result.toString(2)));
            }

            // checking inverse
            if (result === 1) {
                if (!a_inverse) {
                    a_inverse = inverses[a] = b;
                } else if (a_inverse !== b) {
                    throw new Error('inverse already found for ' +
                        a.toString(2) + ' ' + a_inverse.toString(2));
                }
            }

            // checking field commutativity - a*b = b*a
            result2 = gf.mult(b, a);
            count++;
            if (result !== result2) {
                throw new Error('not commutative ' +
                    a.toString(2) + ' * ' + b.toString(2) +
                    ' = ' + result.toString(2) + ' or ' + result2.toString(2));
            }

            /*
			// checking field distributivity for (+,*)
            for (var c = 0; c < gf.size; c++) {
            	assert.strictEqual(m(a, b ^ c), m(a, b) ^ m(a, c));
            	assert.strictEqual(m(a, m(b, c)), m(m(a, b), c));
            }
			*/
            if (count % 5000000 === 0) {
                if (report()) {
                    break;
                }
            }
        }
        if (stopped) {
            break;
        }
        if (a) {
            if (!a_inverse) {
                throw new Error('inverse not found for ' + a.toString(2));
            }
            if (!inverses[a_inverse]) {
                inverses[a_inverse] = a;
            } else if (inverses[a_inverse] !== a) {
                throw new Error('inverse disagree for ' +
                    a.toString(2) + ' ' + a_inverse.toString(2));
            }
        }
    }
    report(true);
}



if (typeof(require) === 'function' && require.main === module) {
    gf_test_all();
}

if (typeof(exports) === 'object') {
    exports = module.exports = {
        GF: GF,
        poly_degree: poly_degree,
        poly_modulo: poly_modulo,
    };
}
